https://level.goorm.io/exam/195698/연합/quiz/1
백준 바이러스와 유사한 문제이다. 그래프로 연결할 때, 몇 개의 집합이 있는가 묻는 문제이다.
DFS와 BFS 방식 두 가지으로 모두 해결했지만, 여기에는 조금 다른 방법을 적어본다.
3주차에서 '탐색'이라는 카테고리에서 DFS와 BFS 응용을 했으니, 4주차에서는 진짜 '그래프'로 풀어보고자 했다.
구름의 출제 의도가 그것이 아닐까? 라는 생각이 들어 다른 그래프 알고리즘을 적용해보았다.
그게 아니라면 DFS와 BFS를 굳이 2주에 걸쳐 할 필요가 없으니 말이다.
Union-Find, 다른 말로는 DSU(Disjoint Set Union)으로 부르는 알고리즘이다.
각 노드(node)를 돌면서, 연결된 노드들 사이에서 root를 찾아 저장한다.
모든 노드를 돌면 각 노드의 저장값은, 루트 노드만이 존재하게 된다.
중복을 제거하면 루트 노드들의 값이 1개씩만 존재할 것이고, 이는 곧 집합의 수와 같다.
밑에서 설명할 알고리즘에서는 Union-Find라는 용어를 기준으로 진행한다.
Union-Find에서 Find를 담당하는 알고리즘이다.
탐색이라는 뜻의 Find로, 특정 노드가 어떤 루트 노드에 속한 그래프인지 탐색하는 알고리즘이다.
parent는 특정 index에 index의 루트 노드를 저장한 list다.
저장한 값과 index가 같다면, 노드 자신이 루트 노드다. 즉, 현재 값(current)를 반환하면 된다.
하지만 저장한 값과 index가 다르다면, 저장한 값을 따라서 루트 노드를 찾아간다.
Union-Find에서 Union을 담당하는 알고리즘이다.
조합이라는 뜻의 Union로, 각 노드들을 특정 루트 노드에 속하게 그래프를 합치는 알고리즘이다.
두 개의 start, end 노드를 입력받고, 두 노드를 루트 노드를 기준으로 하나의 그래프로 합친다.
밑의 함수에서 살펴보겠지만, Union() 함수에 들어온 두 노드는 전제가 '같은 그래프에 속하는 노드'다.
start 노드의 루트 노드는 start_root로, end 노드의 루트 노드는 end_root로 Find() 함수로 계산한다.
여기서는 루트 노드를 더 작은 노드를 기준으로 삼았다.
큰 노드를 기준으로 삼아도 상관없다. 어차피 '집합의 개수'를 세는 문제다. 문제에 따라 조건을 달리 하자.
두 개가 같은 그래프이고, 각각의 루트 노드를 가져왔다. 그럼 더 작은 노드를 기준으로 루트 노드를 변경해준다.
Union() 함수와 Find() 함수를 같이 묶어서 사용하는 Solution() 함수이다.
모든 노드는 초기화(parent)한다. 초기 상태는 자기 자신이 루트 노드인 상태이다.
인접 리스트를 활용하여, 모든 노드를 하나하나 탐색한다.
start 노드(s)와 end 노드(e)가 서로 양방향으로 연결되어 있다면 Union으로 연결한다.
모든 노드를 탐색하고 나면, parent에는 각 index의 루트 노드가 저장된 상태일 것이다.
정답을 넣을 set() 자료 구조로, answer 객체를 선언한다.
마지막으로 모든 노드의 루트값을 Find() 함수로 찾아 저장한다.
문제의 정답은 '집합의 개수'이니 answer의 길이(len)를 반환하면 끝이다.
이때 조심할 점은 parent를 활용한 정답 추출이다.
parent에는 각 노드에 해당하는 루트 노드가 저장된 것은 틀림없다.
그렇다면 굳이 Find()로 다시 찾을 필요 없이, parent를 set()으로 감싼 길이를 반환하면 되지 않은가?
않다. 해당 Union-Find 알고리즘에서는 순서라는 큰 제약이 있다.
반례(counter example)를 살펴보자.
1 2 3 4 5가 있는 상태로, 1-5, 2-3, 3-4, 4-5가 양방향으로 연결되어 있는 상태다.
인접리스트를 초기화하고, 노드를 index 순서대로 돌면서 루트 노드를 검색하고 변경한다.
그럼 parent는 [1, 1, 1, 1, 1]이 되어야 할 것 같지만, 접근 순서 때문에 [1, 1, 2, 2, 1]이 된다.
1과 2는 가장 끝과 끝이지만 분명 연결된 하나의 그래프이다.
순서 때문에 발생하는 오류이니 이 점을 유의하자.약 6개월동안 개인 프로젝트로 앱을 만들었다.
주제는 '갤럭시 워치에서 볼 수 있는 실시간 지하철 앱'이었다.(주제 선정과 그에 대한 이유, 현재까지의 진행 상황, 사용 알고리즘 등은 추후에 따로 정리하여 전부 올린다.)
매년 있는 학과 학술제에 나가, 그동안에 내가 배운 전공에 대해서 어떻게든 응용하려고 했다.
더욱이, 내가 만든 것을 다른 사람과 공유하고 많은 사람이 피드백을 주는 대회인데! 안 나갈 이유가 없다.
1학년 팀프로젝트 2등, 2학년 팀프로젝트 2등, 3학년 개인프로젝트 1등이라는 쾌거를 쥐었다.
그렇게 앱 출시까지 진행하려 앱을 등록하고 심사를 기다렸다.
하지만 내부 테스트라든가 보안 서약에서 무슨 제약이 걸렸다.
또한 내가 이 프로젝트를 시작할 때 ERD나 Flow Chart, Gantt Chart 등 구체적인 계획을 세우지 않았다.
공부를 하면서 진행하기는 했지만, 발표라는 것에 초점을 맞추지 않았다고는 할 수 없었다.
그렇기에 내 마음에 들지 않았고, 해결하지 못한 문제들이 수두룩했다.
실제 개발한 Galaxy Watch Subway Appllication의 화면
그래서 이 프로젝트를 싹 Refactoring하기로 결정했다.
구조부터 서비스까지 모든 것을 다시 계획하여 다시 작성한다.
Android Studio 단 하나의 IDE가 아닌, 데이터베이스와 구조적인 관계를 기반으로 앱을 작성한다.
가장 오른쪽의 화면은 마음에 들지만 노선을 선택하기까지의 화면이 직관적이지 않고, 미관성 좋지 못하다.
그리고 이 카테고리는 이 프로젝트의 시작이다.[ 코드에 들어가기 전에 ]
LinearLayout.LayoutParams Lpara = new LinearLayout.LayoutParams();
Lpara라는 LayoutParams의 변수를 선언한다. 자바에서 Layout을 생성하는 문법이니 이건 이해...보단 암기이다.
LayoutParams( )안의 두 매개변수는 각각 android:layout_width=""와 android:layout_height=""에 해당한다.
저번 실습에서 알아본 weight도 할당하고 싶다면 뒤에 숫자 매개변수 하나만 추가해주면 된다.
LayoutParams(~.MATCH_PARENT, ~.MATCH_PARENT, 1); 처럼 말이다.
LinearLayout baseLayout = new LinearLayout(this);
baseLayout이라는 변수로 LinearLayout을 선언하고 있다. 이해를 하면 좋다만...이 또한 문법이니
XML에서 <LinearLayout> </LinearLayout>에 해당한다.
setContentView(baseLayout, Lpara);
위에서 선언한 layout_width, layout_height, weight, orientation 같은 변수를 묶어주는 느낌이다.
baseLayout(<LinearLayout></LinearLayout>) 안에 저 변수들을 넣으라는 의미의 코드이다.Button btn = new Button(this);
btn.setText("버튼입니다.");
baseLayout.addView(btn);
xml이 아니라 java에서 버튼을 생성하는 코드이다. xml에서의 <Button ~~~ /> 부분
흔히 자바 실습할 때 보는 Scanner처럼 생성자를 활용한 객체 생성 방식이다.
자바에서 객체를 생성해서 findViewById가 아니라 addView를 통해서 화면에 띄어주고 있다.
직접 풀어보기 5-3 실행 결과[ 코드에 들어가기 전에 ]1. 개요2. 접근 제어 행렬2.1. 접근 제어 행렬2.2. 접근 제어 목록(ACL)2.3. 권한 목록(C-List)2.4. 대리 혼돈2.5. 비교3. 다단계 보안 모델(MLS)3.1. 비밀과 취급, 주체와 객체3.2. 다단계 보안(MLS)3.3. 벨-라파둘라(BLP) 모델3.4. 비바(BIBA) 모델4. 다측면 보안4.1. 다측면 보안4.2. MLS와 다측면 보안5. 은닉 통로5.1. 은닉 통로 개념과 예시5.2. 실세계 은닉 통로6. 추론 제어6.1. 추론제어 개념과 요점7. CAPTCHA 튜링 테스트7.1. CAPTCHA8. 방화벽8.1. 방화벽 개념과 종류8.2. 패킷 필터8.3. 상태성 패킷 필터8.4. 응용 프록시8.5. 개인 방화벽9. 침입 탐지 시스템(IDS)9.1. 침입 탐지 시스템(IDS)9.2. 호스트 기반 IDS9.3. 네트워크 기반 IDS9.4. 흔적 탐지9.5. 비정상 탐지
인증(Authentication) : 그곳에 있는 사람이 누구인가?를 판단하여 접근하는 사람을 제한한다.인가(Authorization) : 그것을 하는 것을 허용했는가?를 판단하여 인증받은 사용자의 행위를 제한한다.└ 인가는 '접근 제어 목록'과 '권한 목록'의 방법으로 구현한다.
행은 주체(사용자)를 의미하고, 열은 객체(자원)를 의미한다.이때 각 실행 권한은 리눅스 파일 실행 권한처럼 rwx로 구분한다.각각 읽기(r: read), 쓰기(w: write), 실행(x: execute) 권한에 해당한다.접근 제어 행렬은 주체와 객체 사이의 모든 정보를 가지고 있다.이럴 때 대규모 접근 제어 행렬은 어떻게 관리할 수 있는가?10,000개의 주체, 10,000개의 객체라면 총 항은 1억(100,000,000)개이다.모든 항을 반복문으로 검사한다 생각하면 비효율적인 시간복잡도를 가질 것이다.시간복잡도와 효율 측면에서 개선한 방법은 아니지만, 저장ㆍ관리 측면에서 개선한 방법이 있다.접근 제어 목록(ACL)과 권한 목록(C-List)이다.
접근 제어 행렬을 열 단위로 저장하는 방법이다.이를 접근 제어 목록(Access Control List)이라고 부른다.
접근 제어 행렬을 행 단위로 저장하는 방법이다.이를 권한 목록(Capabilities List)이라고 부른다.
2개의 주체, 2개의 객체(자원)가 있다고 가정해보자.└ 이때 자원은 컴파일러와 청구 정보를 포함하는 청구서 파일(BILL)이다.앨리스는 컴파일러를 호출할 수 있다. 또한 앨리스는 청구서 파일에 기록할 수 없다.컴파일러는 청구서 파일에 기록할 수 있다.이때, 앨리스는 컴파일러를 호출하여 청구서 파일에 기록하는 것이 가능하다.컴파일러는 자신의 권한을 앨리스의 권한과 혼돈한다고 볼 수 있다.이러한 상황을 '대리 혼돈'이라고 한다.대리 혼돈은 ACL을 사용할 경우 불가피하지만, C-List를 사용할 경우 방지가 가능하다.└ 1. 앨리스가 컴파일러 호출 시, 자신의 C-List를 컴파일러에게 전달한다.└ 2. 컴파일러는 앨리스의 C-List를 보고 명령을 거부한다.
접근 제어 목록(ACL)과 권한 목록(C-List)의 화살표가 반대임을 유의하자.ACL을 사용할 경우, 사용자와 파일 간의 관계를 위해 별도의 방법을 사용하여 관계를 규정한다.C-List를 사용할 경우, 사용자와 파일 간의 관계를 시스템 내부에서 구현한다.실제 OS에서는 접근 제어 목록(ACL) 방법을 이용한다.└ 실제 리눅스 환경에서 rwxrwxrwx를 생각하면 이해가 편하다.└ 각 rwx는 소유자, 소유자 그룹, 다른 사용자의 권한을 의미한다.접근 제어 목록(ACL)ㆍ 사용자가 자신들의 파일을 관리하기 용이하다.ㆍ 방어가 데이터 지향적으로 이루어진다.ㆍ 객체(자원)에 대한 권한 변경이 용이하다.권한 목록(C-List)ㆍ 조정(사용자에 대한 권한 변경)이 용이하다.ㆍ 사용자 추가와 삭제가 용이하다.ㆍ 대리 혼돈 방지가 가능하다.ㆍ 구현이 어렵다(Zen of information security 참조).ㆍ 학계에서는 권한 목록을 선호한다(Capabailit Myths Demolished 참조).
비밀 등급은 객체에 적용하고, 취급 등급은 주체에 적용한다.└ 미 국방부에서는 비밀/취급에 대해 4등급(DoD 등급)을 운영한다: 1급, 2급, 3급, 일반└ 2급은 일반적인 경력 검증을, 1급은 엄격한 경력 검증을 요구한다.객체는 O(Object)로 주체는 S(Subject)로 표기한다.보안 등급은 각각 L(O)와 L(S)로 표기한다.이러한 등급에 대해서는 '기준'이 명확하지 않다.또한 어디까지 '세밀'하게 구분하는지도 명확하지 않기에 주의해야 한다.
MLS(Multi Level Security)MLS는 상이한 보안 등급에 있는 주체와 객체가 동일한 시스템을 사용할 떄 필요하다.MLS는 접근 제어의 한 가지 형태이다.└ 예시) 사용자(일반or관리자)에 따른 정보 접근 제한, 네트워크 방화벽, 의료 정보, 데이터베이스 등MLS 모델은 무엇이 수행될 필요가 있는지를 기술한다.이 말은 어떻게 구현할 것인지는 기술하지 않는다는 말이다.간단한 2가지의 MLS 모델에 대해서 살펴본다.
BLP(Bell-LaPadula Confidentiality Model)BLP 보안 모델은 MLS의 필수 요구 사항을 표현하기 위해 설계되었다.BLP는 비밀성을 다루고, 비인가된 판독(읽기 권한)을 방지한다.객체 O는 비밀 등급을 가지고, 주체 S는 취급 등급을 가진다.보안 등급은 각각 L(O)과 L(S)로 표기한다.BLP 구성 요소ㆍ 단순 보안 조건 : S는 O를 L(O) ≤ L(S)인 경우에만 판독할 수 있다.ㆍ * 특성 : S는 O에 L(S) ≤ L(O)인 경우에만 기록할 수 있다상향 판독 금지(NRU; No Read Up)와 하향 기록 금지(NWD; No Wrtie Down)이라고 부른다.반대가 된다면 상위 보안 등급의 내용을 하위 보안 등급에 작성할 가능성이 생긴다.
BLP는 안정성을 보강한다.ㆍ 강성 안정 특성 : 보안 등급이 불변한다.ㆍ 약성 안정 특성 : 보안 등급이 '확정된 보안 정책'을 위반하지 않는 경우에 한하여 바뀔 수 있다.강성 안정 특성은 실세계에서 비실용적이다.사용자에게 최소한의 권한만을 부여하는데,'권한 한정'을 적용할 경우 권한 상승이 필요할 수도 있다.└ 권한 한정 : 필요에 따라 취급 등급을 향상하는 것이런 규제를 정책으로 허용해야 하는 상황이 발생한다.이는 '고수위 원칙'으로 알려져있다.└ 고수위 원칙 : 두 가지를 포함하는 객체는 둘 중 더 높은 보안 등급을 가진다.이에 비해, 약성 안정 특성은 권한 한정을 허용하지만, 특성 자체가 모호해진다.맥린의 비판"BLP는 너무나 당연한 것이어서 실제로 BLP를 준수하지 않는 모델을 상상하는 것조차 어렵다."맥린이 제시한 시스템 Z는 관리자로 하여금 객체를 재등급화하여 '하향 기록'을 허용한다.
보안 모델이 매우 단순하다.시스템에서 증명에 사용할 수 있는 몇 안 되는 보안 모델이다.다른 보안 모델들에 영향을 주었다.
BIBA Integrity ModelBLP는 무결성을 다루고, 비인가된 기록을 방지한다.BIBA 모델은 BLP와 상생 관계라고 말할 수도 있다.I(O)는 객체 O의 무결 등급을, I(S)는 주체 S의 무결 등급을 나타낸다.비바 모델 구성 요소ㆍ 기록 접근 규칙 : S는 I(O) ≤ I(S)인 경우에만 O를 기록할 수 있다.ㆍ 비바 모델 : S는 I(S) ≤ I(O)인 경우에만 O를 판독할 수 있다.하향 판독 금지(NRD; No Read Down)와 상향 기록 금지(NWU; No Write Up)이라고 부른다.자신보다 낮은 등급의 객체로부터의 무결성 오염을 방지하는 방법이다.
무결성 모델O1의 무결성은 신뢰하지만, O2의 무결성은 신뢰하지 않는다고 가정해보자.객체 O가 O1, O2를 포함한다면 O의 무결성은 신뢰할 수 없게 된다.결국 O의 무결성 등급은 O안에 있는 여러 객체들 중 최소(가장 좁은 범위) 무결성을 채택해야 한다.비바 모델의 판독 정책은 너무 제약적이다.경우에 따라, 비바 모델은 저수위 원칙으로 대체하여 사용한다.만약 S가 O를 판독한다면, I(S) = min(I(S), I(O))를 가진다.\
BLP : 비밀성, 고수위 원칙(NRU, NWD)BIBA : 무결성, 저수위 원칙(NRD, NWU)
다단계 보안(MLS)은 상하 간의 접근 제어 구현을 한다.이러한 보안 등급의 단순한 계층은 충분한 융통성을 제공하지 못한다.다측면 보안(Compartment Security)은 구획 생성에 따른 횡적 접근 제어 구현을 한다.1급 비밀을 1급 비밀{갑}과 1급 비밀{을}로 분리하는 것이다.두 가지 모두 1급 비밀에 해당하지만 상호 간의 정보 흐름은 제한한다.
구획으로 나눔으로써 지식 한정 원칙을 구현할 수 있게 한다.본인의 등급이 무엇이든, 본인에게 필요한 정보에 대해서만 접근이 가능하게 한다.이때 모든 보안 등급들이 화살표로 연결된 것은 아니다.이말은즉, 모든 보안 등급들이 비교 가능한 것은 아니다.
MLS(다단계 보안)는 다측면 보안과 무관하게 사용할 수 있으며, 그 반대도 마찬가지다.하지만 MLS는 다측면 보안을 항상 포함하고 있다.└ 예시) 영국 의료 연합(BMA; British Medical Association)의 의료 정보를 보호하기 위해 MLS를 운영└ 예시) AIDS(1급 비밀)와 AIDS의 처방전(2급 비밀)일 때, 약에 대한 처방전 비밀 등급은 무엇인가? > 다측면 보안을 사용
MLS는 적법한 통로를 사용하는 통신으로 제한하기 위하여 설계되었다.하지만 다른 등급의 자원에게 정보를 보내는 것처럼, 적법한 통로를 이용하되 흐름마저 통제할 수는 없다.이런 식의 통로를 은닉 통로라고 부른다.└ 은닉 통로 : 시스템 설계자들이 의도하지 않은 통신 경로은닉 통로를 통해 BLP의 NRU, NWD 등의 제약 사항을 위반할 수 있다.은닉 통로가 만들어질 수 있는 조건ㆍ 송신자와 수신자가 자원을 공유한다.ㆍ 송신자는 자원의 특성을 변경할 수 있고, 수신자는 이를 볼 수 있다.ㆍ 송신자와 수신자 사이에 통신이 동기화될 수 있다.은닉 통로는 거의 대부분의 상황에 존재한다.유용한 시스템 상에서 모든 은닉 통로를 봉하고 제거한다는 것은 사실상 불가능하다.실제 DoD(Department of Defense; 미국방부) 지침의 목표는 은닉 통로 용량을 초당 1bit를 넘지 않는 것이다.이건 DoD조차 은닉 통로를 완전히 제거하지 못함을 반증하는 것이다.예시 1)앨리스는 1급 비밀 등급, 밥은 2급 비밀 등급을 가지고 있다고 가정해보자.이때 파일 공간이 모든 사용자들이 공유한다고 가정한다.앨리스는 밥에게 "1"을 보내기 위해FileXYzW를 생성하고, "0"을 보내기 위해FileXYzW를 제거한다.└ 어떤 특정 파일을 생성하는 신호로 1을 보내고, 삭제하는 신호로 0을 보낸다는 의미이다.밥은 1분마다 파일 목록을 검사한다.FileXYzW가 없다면 0을, 있다면 1을 송신한 것으로 간주한다.이런 식으로 앨리스는 밥에게 1급 비밀 정보를 누설할 수 있다.예시 2)100MB의 1급 비밀 파일이 있다고 가정해보자.평문은 1급 비밀 장소에 저장한다.이 파일은 256bit 키를사용한 AES로 암호화했고, 암호문은 일반 평문 장소에 저장했다.DoD 지침처럼 은닉 통로 용량을 초당 1bit로 제한했다고 해보자.은닉 통로를 통해 파일 전체를 누설하려면 25년이 소요된다.하지만 AES의 256bit 키를 누설하려면 5분이면 충분하다.그 밖의 은닉 통로 예시)ㆍ 프린터 큐ㆍ ACK 메시지ㆍ 네트워크 트래픽
실세계에서 은닉 통로를 활용하는 방법을 다양하다.TCP 헤더의 Reserved field를 숨긴다거나 covert_TCP를 사용하여 일련번호나 ACK 번호에 데이터를 숨긴다.
본 방법에서는 covert_TCP 도구를 활용하여 데이터를 TCP 순서 번호에 숨겼다고 가정해보자.이때 순서 번호 X는 은닉 정보를 포함하고 있다.A는 C로 데이터를 숨긴 패킷을 보내고 싶어한다.이때 A는 마치 C가 보낸 것처럼 출발지를 바꿔, 서버에게 자신의 패킷을 송신한다.그럼 서버는 올바르지 않은 패킷임을 확인하고 패킷을 다시 C에게 돌려준다.하지만 서버가 돌려준다고 착각을 하는 것이지 실제로는 A의 패킷이 C에게 송신된 것이다.결과적으로 3WHS 과정을 거쳐서 은닉 통로를 생성하게 된다.
데이터베이스에 다음과 같은 질의응답을 진행했다고 가정해보자.Q. D대학 C학과 교수의 평균 연봉은?A. 10,000,000원Q. D대학 C학과 교수의 수는?A. 1명이런 질의응답으로 특정 인원의 평균 연봉을 알 수 있게 되었다.일반적인 질의를 통해 얻은 정보를 조합하여, 특별한 정보가 되는 상황을 '추론'이라고 한다.'추론 제어'는 이런 상황을 방지하는 것이 목표이다.추론 제어는 특정 정보를 연구에 사용하면서 개인 정보를 어떻게 하면 보호할 수 있을까?라는 의문에서 시작했다.가령 의료 정보는 사소한 개인 정보를 포함하지만, 연구 자료로써 가치는 상당하다.이름을 제거(익명화)한다면 추론 제어가 가능하지 않을까?D대학 C학과 교수의 상황을 보더라도, 익명화는 충분하지 않음을 알 수 있다.질의 결과의 크기를 제어한다면 어떨까? 질의 결과 크기가 너무 작으면 답을 주지 않는 것이다.이를 N응답 K% 지배 규칙이라고 한다.└ N 이하 주체에 의해 제공하는 데이터가 K% 이상이면 공개하지 않는다.└ 예시) 빌 게이츠 이웃의 평균 연봉으로 빌 게이츠의 평균 연봉을 추론할 때, N과 K를 적절히 조절하면 빌 게이츠의 연봉을 알기 어렵다.└ 미 조세조사국에서 현재 사용하는 방법이다.여기에 '무작위화'를 더하여 추론 제어에 힘을 싣는다.└ 무작위화 : 데이터에 적은 양의 무작위 잡음을 추가하여 결과를 반환한다.다른 많은 방법들이 존재하지만 만족스로운 추론 제어 방법은 현재 없다.
완벽한 추론 제어는 불가능하다.취약한 추론 제어가 추론 제어를 하지 않은 것보다 나은가?> Yes : 정보가 누설하는 양이 줄어 손상을 제한한다.취약한 암호화가 암호화를 하지 않은 것보다 나은가?> Probably Not : 암호화 자체가 중요한 정보라는 것은 반증한다.
튜링 테스트는 1950年 앨런 튜링(Alan Mathison Turing)이 제안하였다.질문자가 다른 사람과 컴퓨터에게 동일한 질문을 던진다.만일 질문자가 받은 두 응답을 구별할 수 없다면 컴퓨터는 테스트를 통과한 것이다.현재 인공지능 분야의 기준이 되기도 한 테스트이다.
CAPTCHA(CompletelyAutomatedPublicTuring test to tellComputers andHumansApart)Automated : 컴퓨터가 자동으로 테스트를 출제하고 채점한다.Public : 프로그램과 데이터는 공개한다.Turing test to tell : 사람은 통과할 수 있지만, 기계는 통과할수 없다.CAPTCHA의 역설(paradox)컴퓨터가 출제하고 채점하지만 컴퓨터 본인은 통과할 수 없는 상황이다.CAPTCHA는 자원에 대한 사람들의 접근을 제한하는데 사용한다.따라서  CAPTCHA는 접근 제어에 유용하다.최초의 CAPTCHA 사용 동기전산학과 최우수 졸업 프로그램 선정 투표를 하는 것이었다.선정 투표를 온라인으로 하는데 SPAM 계정으로부터 잔뜩 받아 사람을 특정 짓는 것이 필요했다.이떄 CAPTCHA를 활용하여 사람만이 계정을 얻을 수 있게 필터링하였다.CAPTCHA 게임 법칙대부분의 사람은 통과하기 쉽고, 기계가 통과하기는 불가능하거나 어려워야 한다.일부 사람들이 한 형태의 CAPTCHA를 통과하지 못함에 대비해 다른 형태의 CAPTCHA를 준비해야 한다.위의 사진 예시처럼 시각 형태의 사진 CAPTCHA나, 음성같은 청각 CAPTCHA도 다양하게 존재한다.└ 시각 장애인은 사진 CAPTCHA를 통과할 수 없다.
방화벽ㆍ 내부 네트워크에 무엇을 들어오게 할 것인지 결정하는 규칙ㆍ 네트워크에 대한 접근 제어라고 할 수 있다.방화벽의 종류ㆍ 패킷 필터 : 네트워크 계층(Layer 3, Network layer)에서 동작하는 방화벽ㆍ 상태성 패킷 필터 : 전송 계층(Layer 4, Transport layer)에서 동작하는 방화벽ㆍ 응용 프록시 : 응용 계층(Layer 7, Application layer)에서 동작하는 방화벽ㆍ 개인 방화벽 : 개인 사용자, 홈 네트워크에서 설정하는 방화벽// 위의 계층은 ISO OSI 7 Layer의 기준에 따른다.
네트워크 계층(Layer 3, Network layer)에서 동작하는 방화벽이다.다음 내용에 기반하여 필터링을 진행한다.ㆍ 출발지 IP 주소ㆍ 목적지 IP 주소ㆍ 출발지 포트ㆍ 목적지 포트ㆍ 플래그 비트(SYN, ACK)ㆍ Egress or Ingress└ Egress : 서버 내부에서 외부로 나가는 네트워크 트래픽└ Ingress : 외부로부터 서버 내부로 유입하는 네트워크 트래픽장점 : 속도가 빠름단점 : 비상태, TCP 연결을 볼 수 없음, 응용 데이터를 볼 수 없음
의도 : 웹 요청/응답으로 들어오는 패킷들을 80번 포트로만 제한하는 것
공격자는 패킷을 ACK 비트를 설정하고, 3WHS 전에 송신한다.└ 이는 TCP/IP 프로토콜을 위반하는 행위이다.이렇게 보낸 ACK 패킷은 패킷 필터 방화벽을 통과하고, RST는 수신 확인 패킷을 송신한다.공격자는 방화벽을 통하여 개방 포트를 스캔할 수 있다.└ 위의 그림에서는 1209번 포트가 개방되어 있음을 알 수 있다.└ 상태성 패킷 필터에서는 이런 공격을 막을 수 있다.
전송 계층(Layer 4, Transport layer)에서 동작하는 방화벽이다.패킷 필터에 '상태'를 추가하는 방법이다.TCP 연결과 FLAG 비트를 기억한다. (UDP 패킷도 기억할 수 있다.)장점 : 패킷 필터가 하는 모든 것을 할 수 있다, 진행 중인 연결을 추적할 수 있다.단점 : 응용 계층 데이터는 보지 못한다, 패킷 필터보다 느리다.
프록시(Proxy) : 본(origin) 대신 동작하는 어떤 것(Proxy server를 생각하면 편하다.)응용 계층(Layer 7, Application layer)에서 동작하는 방화벽이다.응용 프록시는 진입하는 데이터를 관찰하여 안전성을 검증한다.장점 : 연결과 응용 계층 데이터를 볼 수 있다, 응용 계층에서의 불량 데이터(바이러스나 매크로 등)를 필터링할 수 있다.단점 : 속도가 느리다.내부 네트워크를 통해서, 전송하기 전에 새로운 패킷을 생성한다.공격자는 프록시와 통신하여 메시지가 전달된다는 사실에 대한 확신을 얻는다.프록시는 연결을 완전하게 볼 수 있기에 신뢰 가능하다.상태성 패킷 필터가 하지 못하는 몇 가지 공격 또한 막을 수 있다.
Firewalk는 포트 스캔 도구로, 방화벽의 IPㆍ방화벽 내부 시스템 IP 등을 알 수 있다.TTL 값을 '거쳐가는 방화벽 수'로 설정하고, 목적지 포트를 N이라고 한다.만일 방화벽이 N을 통해 데이터를 통과시키지 않는다면 '응답 없음' 신호를 받는다.만일 방화벽이 N을 통해 데이터를 통과시킨다면 '시간 초과' 에러 메시지를 받는다.
응용 프록시는 새로운 패킷을 생성하고 이전 TTL을 제거하는 방식으로 동작한다.그렇기에 응용 프록시로는 동작하지 않는다.
개인 사용자와 홈 네트워크를 방어하는 방화벽이다.패킷 필터, 상태성 패킷 필터, 응용 프록시의 3가지 방법만을 사용할 수 있다.
응용 프록시를 활용한 종심 방어의 예시이다.여러 단계의 방어를 포함하고 있다.
컴퓨터 보안의 주 쟁점은 악의적인 사람들이 들어오지 못하게 하는 것이다.이것이 곧 '침입 방지'이다.침입 방지는 컴퓨터 보안의 전통 관심사로 다양한 형태로 구현해왔다.└ 인증, 방화벽, 바이러스 방지 모두 침입 방지의 한 형태이다.침입 방지에도 불구하고 악의적인 사람들이 시스템 내부로 들어올 수 있다.이를 위해 '침입 탐지 시스템(IDS; Intrusion Detection System)'이 필요하다.IDS는 공격 탐지와 비정상적인 행위를 감시하는 역할을 맡는다.침입자는 뭐라고 정의할 수 있는가?> 방화벽을 뚫고 들어오려는 외부인 or 악의적인 내부인침입자는 무엇을 한다고 정의할 수 있는가?> 잘 알려진 공격 / 잘 알려진 공격 변형 / 새로운 혹은 덜 알려진 공격 / 타 시스템을 공격하기 위한 경유 등 다양한 시도침입 탐지 구조에 따라 '호스트 기반 IDS'와 '네트워크 기반 IDS'로 구분한다.침입 탐지 방법에 따라 '흔적 기반 IDS'와 '비정상 기반 IDS'로 구분한다.
침입 탐지 구조에 따른 분류에 속하는, 호스트 기반 IDS이다.호스트(Host) 상에서 '알려진 공격', '의심스러운 행위'들을 감시한다.주로 '버퍼 오버플로우'나 '권한 상승' 등의 공격을 탐지하는 게 주 목적이다.네트워크에서의 행위 관찰은 거의 없다.
침입 탐지 구조에 따른 분류에 속하는, 네트워크 기반 IDS이다.네트워크(Network) 상에서 '알려진 공격', '네트워크에서 의심스러운 행위'들을 감시한다.주로 '서비스 거부(DoS)', '네트워크 탐침', '잘못 구성된 패킷' 등을 탐지하는 게 주 목적이다.방화벽과 중복되는 부분이 일부 존재한다.호스트 기반 공격들에 대한 관찰은 거의 없다.호스트 및 네트워크 양쪽 모두에 기반한 IDS 조합을 사용할 수 있다.
침입 탐지 방법에 따른 분류에 속하는, 흔적 기반 IDS이다.M초 동안 N번 이상 로그인에 실패할 경우 IDS가 경고를 발생한다고 해보자.정상적인 행위에 기반하여 오경고가 일반적이지 않게 N과 M을 조정한다.만약 공격자가 위 방식을 알고 있다면, M초 동안 N-1번 로그인 시도를 감행할 수 있다.이런 경우 공격을 지연할 수는 있어도 멈출 수는 없다.결국 목표는 '흔적에 가까운 것'을 탐지하여 공격을 막는 것이다.대략 M초 동안 약 N번의 공격이라면, '대략'과 '약'의 기준이 모호하다.고로 오경고 비율이 증가하지 않도록 유의해야 한다.장점ㆍ 간단하다ㆍ 알려진 공격을 탐지할 수 있다.ㆍ 탐지 시점에서 어떤 공격인지 알 수 있다.ㆍ 흔적들의 종류가 적절한 경우 효율적이다.단점ㆍ 흔적 정보 파일을 지속적으로 갱신해야 한다.ㆍ 흔적 종류가 매우 많아질 수 있다.ㆍ 알려진 공격만 탐지 가능하다.ㆍ 공격이 변형되면 탐지할 수 없다.
침입 탐지 방법에 따른 분류에 속하는, 비정상 기반 IDS이다.일상적이지 않은, 비정상적인 행위를 관찰한다.비정상 탐지는 2가지 해결 과제가 존재한다.ㆍ 시스템에서 '정상'이란 무엇인가?ㆍ '정상'으로부터 얼만큼 떨어져 있어야 '비정상'으로 구분하는가?통계를 활용하여 정상(평균)과 비정상(평균으로부터 떨어진 정도)을 판단한다.그렇다면 어떤 통계 측정 방법으로, 언제 측정할 것인지도 논의해야 한다.행동이 '행해질 때' 측정하고, 공격 중이거나 공격이 정상처럼 보일 동안은 측정하지 않는다.'비정상'은 다음과 같은 통계적 판별 기법들을 사용하여 판단할 수 있다.ㆍ 베이지안 통계(Bayesian Statistics)ㆍ 선형 판별 분석ㆍ 2차 판별 분석ㆍ 인공신경망ㆍ 인공 면역 시스템ㆍ 은닉 타르코프 모델(시계열 기반)장점 : 알려지지 않은 공격 탐지 기회를 제공한다, 흔적을 관리하지 않기에 더 효율적이다.단점 : 독자적으로 사용할 수 없다(흔적 기반과 병행 필요), 신뢰가 불분명하다, 공격에 노출이 쉽다, 정상/비정상 판단이 어렵다예시 )비정상 탐지에서 3가지 명령어(open, read, close) 사용을 감시한다고 가정해보자.정상 사용자의 명령어 사용을 기반으로 가능한 순서쌍을 수집한다.특정 사용자의 명령어 사용에서 비정상 쌍의 비율을 판단하여 공격 가능성을 경고한다.이 방법은 다음과 같은 방법으로 성능을 향상할 수 있다.ㆍ 각 쌍의 예상 빈도를 사용한다.ㆍ 2개 이상의 연속된 명령어를 사용한다.ㆍ 더 많은 명령어/행위를 모델에 포함한다.ㆍ 더 복잡한 통계적 판별을 사용한다.
전체 앨리스의 파일 접근 비율이 있을 때, 최근 접근 비율을 따져보자.이것이 과연 정상적인 사용인가?
다음과 같은 코드를 얻어 S를 계산하여 0.1 미만이라고 한다면 정상이라고 해보자.이때 값은 0.02로 정상이다.과연 이런 편차를 장기간에도 적용할 수 있을까?
장기간 평균을 구했더니 왼쪽의 표가 나오고, 새롭게 관측했더니 오른쪽의 표가 나왔다고 해보자.위 식에 따라 계산한다면 0.0488로 정상으로 간주한다.
장기간 평균을 구해 정상/비정상을 판단하는 과정은 시간이 오래 걸린다.시간이 오래 걸리는 만큼 관리자의 부담을 덜어준다.하지만 이는 곧 공격자에게도 길을 열어주는 것과 같다.공격자가 처음부터 한 곳을 집중적으로 공격하지 않고, 위의 표처럼 시간을 들여 서서히 접근한다고 해보자.IDS 입장에서는 이러한 접근이 정상이라고 확신할 것이다.이런 허점을 보완하기 위해서는 편차도 고려해야 한다.NIDES라는 더 복잡한 방법을 IDS에서 사용한다.└ NIDES :Next-generationIntrusionDetectionExpertSystemNIDES는 비정상 및 흔적 기반 IDS를 포함한다.
ㆍ 시스템이 지속적으로 변하기에 IDS도 그에 맞게 바뀌어야 한다.ㆍ 모호한 경고는 구체적인 대응을 어렵게 한다.ㆍ 대부분의 보안 전문가들은 이 방법이 궁극적으로 성공할 것이라 기대한다.ㆍ 미래 보안의 핵심이라고 간주한다.ㆍ AI만큼 어려운 방법이라는 의구심이 남아있다.1번 풀이, 파이썬 라이브러리 combinations를 활용한 방법
Python3에서도 시간 초과없이 무난하게 통과 가능하다.
2번 풀이, Backtracking을 활용한 방법
Pypy3에서만 통과하고 Python3에서는 시간 초과가 뜬다.SQL에서 Database와 Table을 예제를 생성한 상태의 MySQL이다.
좌상단의 SCHEMAS를 보면 'codingtable'이라는 Database와 'cats'라는 Table이 있는 것을 볼 수 있다.
또한, 좌하단의 Schemas를 보면 'cats' Table이 어떤 columns이 있는지 확인할 수 있다.
현재는 'cat_id' 값이 기본키로 들어가있으며, name, breed, age가 column으로 있다.
MySQL이라는 DBMS를 사용하면 당연히 데이터베이스를 다룰 줄 알아야 한다.
위의 그림을 예시로 들면, 4개의 각기 다른 색에 해당하는 구역이 하나의 Database이다.
각 색상에 들어있는 다양한 크기의 사각형들이 Table이다.
이번 글에서 가장 기본이 되는 데이터베이스를 확인, 생성, 삭제하는 구문을 다루고,
데이터베이스 내부에 존재하는 테이블들을 확인, 생성, 삭제하는 구문을 다룬다.
현재 MySQL에 있는 모든 데이터베이스 목록을 보여준다.
새로운 데이터베이스를 생성한다.
new_db_name에 자신이 새롭게 생성하고자 하는 데이터베이스 이름을 적으면 된다.
SQL에서 삭제할 때는 보통 DROP 키워드를 사용한다.
del_db_name에 삭제하고자 하는 데이터베이스 이름을 적으면 된다.
데이터베이스 내부에 테이블을 생성하기 위해서는 데이터베이스에 접근해야 한다.
use_db_name에 접근할 데이터베이스 이름을 적으면 된다.
이때 MySQL Workbench 좌측창에서 더블 클릭으로 접근해도 상관없다.
현재 선택한 데이터베이스를 확인한다.
데이터베이스 내부에 존재하는 테이블 목록을 보여준다.
특정 테이블의 정보를 확인한다.
특정 테이블의 Field, Type, Null, Key, Default, Extra 값들을 보여준다.
table_name에 보고 싶은 테이블 이름을 적으면 된다.
테이블을 삭제할 때 사용한다. del_table_name에 삭제할 테이블 이름을 적으면 된다.
테이블을 생성하는 방법이다.
위에서 언급한 것처럼 테이블에는Field, Type, Null, Key, Default, Extra 값이 존재한다.
그에 따라 테이블을 생성할 때는 값을 명시해줘야 한다.
가장 간단한 형태로 테이블을 생성한 예시이다.
cats라는 이름으로 테이블을 생성하고 name, breed, age의 Field를 생성했다.
name과 breed는 최대 문자열 100자를 받을 수 있는 타입(VARCHAR(100))으로,
age는 정수값을 받아들일 수 있는 타입으로 선언했다.
또 다른 예시로 people이라는 이름의 테이블을 생성했다.
테이블의 NULL 속성은 해당 열(column)이 NULL을 허용하는지 안 하는지를 나타낸다.
이때 Field를 NOT NULL로 선언한다면 NULL 값을 허용하지 않는다.
테이블을 생성하고, 그에 해당하는 값을 추후에 입력해야 한다.
이때 해당 값에 아무 것도 입력하지 않았을 때, NULL 값으로 들어가게 된다.
NULL이 아니라 특정 값을 넣고 싶다면 DEFAULT로 기본 값을 설정할 수 있다.
NOT NULL과 DEFAULT를 같이 선언한다면 어떻게 될까?
DEFAULT 값을 선언했으니 NOT NULL이 의미가 없는 것은 아닐까?
DEFAULT는 아무 것도 입력하지 않았을 때, 특정 값을 넣어준다는 제약이다.
입력값으로 직접 NULL을 넣어주면 DEFAULT가 동작하지 않는다.
이를 NOT NULL로 방지할 수 있다.
기본키(Primary key)를 사용한 테이블 생성 예제다.
name과 age가 같은 두 마리의 고양이를 입력했다고 해보자. 이를 어떻게 구분할 수 있을까?
이때 필요한 것이 기본키다. 기본키라는 것은 행(row)을 구별하기 위한 고유한 값이다.
기본키는 PRIMARY KEY 키워드로 해당 Field를 기키로써 선언할 수 있다.
기본키로 선언하는 방법에는 위의 2가지가 있다.
기본키를 하나하나 직접 입력하기에는 번거롭다. 그를 위한 AUTO_INCREMENT 옵션이 있다.
AUTO_INCREMENT는 기본키를 1부터 시작하여 자동으로 1씩 올려서 저장해준다.
주의할 점은 PRIMARY KEY에는 언더스코어가 들어가지 않고, AUTO_INCREMENT에는 언더스코어가 들어간다.
위처럼 생성한 테이블들을 DROP으로 삭제할 수 있다.중세 프랑스에서의 도박은 단순했다.
몇 명이 모여서 단지 하나와 닭 한 마리만 있으면 됐다.
모든 사람이 단지에 똑같은 액수의 돈을 넣고, 손을 휘저어 닭을 적당한 거리로 쫓아낸다.
적당히 얼마쯤? 돌 던지면 닿을 정도(A stone's throw)로만
그리고 돌아가면서 닭에게 돌을 던진다.
닭은 날개를 퍼덕거리면서 도망다닌다. 이 닭을 제일 먼저 맞히는 사람이 돈을 모두 가져간다.
마지막으로 동물보호협회에 절대 신고하지 않기로 서로 약속하면 도박이 끝난다.
이게 프랑스 사람들이 즐겨하던 Game of chicken이다.
당연히 프랑스 사람들은 프랑스어를 사용한다.
닭은 Poule[풀]이라고 하고, 이런 놀이를 Jeu de poule[죄 드 풀]이라고 했다.
이 말이 닭 맞히기 놀이뿐만 아니라 다른 분야에서도 쓰이기 시작했다.
카드 게임을 할 때 테이블 가운데 놓는 돈 단지를 poule이라고 불렀다.
17세기 영국 도박꾼들이 그 단어를 자국으로 수입했고, 철자는 Pool로 바뀌었다.
어찌됐든 테이블 가운데에 놓는 돈 단지는 Pool of money가 되었다.
Billiards(당구)가 인기를 끌면서 사람들이 내기 당구를 치기 시작했다.
그래서 돈을 걸고 하는 당구의 한 종류도 Pool이라고 불렀고, Shoot pool하면 '당구를 치다'가 되었다.
그렇게 마침내 불쌍한 프랑스 닭을 뜻하던 Pool은 음지에서 벗어나 양지로 진출했다.
도박꾼들이 돈을 Pool하는 이미지에 착안해 여러 의미로 사용했다.
'자원을 공유하다'라는 의미로 Pool thier resouces라 하고,
'차를 공유하다'라는 의미로 Pool their cars라고 했다. 이게 Car pool[카풀]이다.
급기야 Labour pool(인력풀)이라는 단어도 생겨났다.
결국 Pool은 개인을 넘어 인류 전체를 아우르는 개념으로 뻗어 나갔다.
1941년 만들어진 Gene pool(유전자풀)이 그것이다.
어원적으로 보면 우리는 모두 닭에서 파생한 셈이다.
// 참고로  Poule에서 바뀐 Pool은 물웅덩이를 뜻하는 Pool과는 어원적으로 전혀 다르다.
// 이말은 곧 Swimming pool(수영장), Rock pool(조수 웅덩이), Liverpool(리버풀)과는 무관하다.
출처 : 걸어다니는 어원 사전1748번: 수 이어 쓰기 1
첫째 줄에 N(1 ≤ N ≤ 100,000,000)이 주어진다.
www.acmicpc.net
어째 갈수록 문제는 쉬운데 이걸 어떻게 해야 할지 잘 모르겠는 문제들이 많아지는 기분이다.
마치 사람이랑 대화하는 기분이다. 속내를 파악하기 위해서 열심히 생각하는... 그냥 있는 그대로 말해주면 좋으련만.
N이 주어졌다고 해보자. 1부터 N까지 일렬로 쭉 나열한다.
이때 이 숫자는 몇 자리일까?를 물어보는 문제이다.
정말 단순하게 생각하면 str으로 쭉 작성한 다음에 len으로 길이를 더하면 되는 문제이다.
하지만 당연히 이렇게 쉬울리는 없을 거다. 시간 제한이 무려 0.15초이다. 위의 코드는 당연히 시간 초과다.
Python3는 0.5초이지만 까딱하면 나가버리는 살벌한 시간이다.
이런 문제는 당연히 수학 개념이 들어간다고 생각해 99까지는 구해보았다.
1부터 9까지의 한 자릿수는 숫자만큼의 길이를 갖는다.
10부터 99까지의 두 자릿수는 우선 9만큼의 길이를 갖고, N-9만큼의 숫자에 2를 곱한 길이를 갖는다.
이제 99가 입력일 때, 길이가 189임을 알아냈으니 세 자릿수를 확인해보자.
세 자릿수 입력은 두 자릿수 입력과 비슷한 양상을 보이긴 한다.
뒤에 곱하는 수는 규칙이 보이는 것 같은데, 앞에 더해주는 수는 어떤 규칙을 갖고 있는지 잘 모르겠다...
9와 189가 무슨 상관 관계가 있는 거지? 그래서 네 자릿수까지 확인을 해주었다.
네 자릿수 확인을 위해서는 999가 입력일 때 길이를 알아야 한다.
189 + (999-99) * 3 = 2889이다.
아 네 자릿수까지 오니까 규칙이 보이기 시작했다.
특히 2889 부분이 보였다.
9는 0 + 9이고, 189는 180 + 9이고, 2889는 2700 + 180 + 9이다.
뒤의 0을 다 떼고 보면 27, 18, 9가 있다. 9의 배수에 10의 제곱꼴을 곱해준 형태이다.
10의 몇 제곱을 곱해줘야 하는지는, 입력받은 자릿수에 따라 정해진다.
N의 형태를 식으로 일반화할 수 있게끔 형태를 바꾸어주었다.
좌변과 우변을 순서대로 작성하긴 했지만, 우변의 규칙이 더 쉽기에 우변부터 정리한다.
우변을 계산할 때 N은 입력받은 숫자이다. 그리고 식은 자릿수에 따라서 결정한다.
그리고 length는 N의 자릿수라고 해보자. 만약 241이라면 length는 3이다.
한 자리일 때는 10의 0제곱을, 두 자리일 때는 10의 1제곱을... 이런 식으로 나아간다.
즉 10의 length-1 제곱을 한 뒤에 1을 빼고, 이 값을 N에서 뺀다. 그리고 length를 곱해주면 된다.
그렇게 (N - (10 ** (length - 1) - 1)) * length라는 식이 완성된다.
좌변을 정리한 식에서 => 이후의 값은 그 전 식에서 새로 추가된 숫자들만 정리한 것이다.
예를 덜어 9 * 10^0 * 1은 9를 의미하고, 9 * 10^1 * 2는 180을 의미한다.
마찬가지로 N의 자릿수를 length라고 하면, 9 * (10 ** (length - 1)) * length라는 식이 완성된다.
핵심은 위에서 계산한 모든 값들을 전부 더해야 한다.
전체적으로 정리하자면 코드는 위와 같다.
N을 문자열로 입력받고 길이를 length에 넣어준다.
좌변은 for문을 돌며 값을 더해준다. 그리고 우변은 해당 식을 한 번만 계산하면 된다.
이때 괄호에 주의해야 한다. N - (10**(length-1)-1) 부분의 괄호를 풀면 N - 10 ** (length-1) + 1가 된다.
다른 사람들이 어떻게 풀었나보다가 +1이 있는 것을 보고 왜 더하기지??
분명 식을 유도했을 때는 -1이어야 하는데??하는 의문이 있었다. 괄호를 조심하자.
이런 방법으로 나름 간단하게 수식을 유도하는 문제는 가끔 풀어주면 재미있다.[ 코드에 들어가기 전에 ]
android:id="@+id/(원하는 이름)"
id 속성은 위젯에 아이디를 새로 부여한다는 개념이다. 고로 @+id라는 형식을 사용한다.
이런 아이디는 버튼, 텍스트, 이미지 등의 무언가 작동하고 실질적인 기능이 들어있는 위젯에 부여한다.
특정 텍스트 뷰와 같이 실질적인 기능이 아예 없는 경우에는 굳이 id 속성을 부여하지 않아도 된다.
android:ems="10"
em이란 타이포그래피의 단위 중에 하나로 문자의 너비를 의미한다. 따라서문자열의 width를 고정한다.
ems는 오직 layout_width가 wrap_content일 때만 사용가능하다. em의 자세한 설명은 위키피디아 참고.
https://en.wikipedia.org/wiki/Em_%28typography%29
android:textSize="30sp"
android:layout_margin="15dp"
저번에 dp와 sp에 대해서 작성했는데 이해가 안 되서 더 찾아봤다.
dp는 Density inpendent Pixels로 밀도에 대한 픽셀이라는 의미이다. 쉽게 풀어서 설명하자면 밀도,
화면의 밀도(비율)만큼 글자가 있다는 것이다. 그럼 화면 비율이 바뀌어도? 글자가 깨지지 않고 같은 비율을 유지한다.
그에 반해 sp는 Size inpendent Pixels로 크기에 대한 픽셀이라는 의미이다. 고로 비율이 바뀌거나,
설정에서 크기값에 변경을 주거나 하면 글자가 깨지거나 크기가 바뀌는 픽셀이라는 의미이다.
코드를 짜던 도중 알게 된 건데 이 단위가 이미지에서도 적용이 된다. 즉 이미지나 명함의 글자같이
크기가 변경이 되면 안 되거나, 정확한 비율을 고정시켜야 하는 경우에는 dp를 사용하면 된다.
반대로 폰트 크기 조절이 필요하거나 유동적인 크기를 원할 때에는 sp를 사용하면 되는 것이다.
추가로 Activity의 여백은 padding이고, 위젯의 여백은 margin이라는 차이가 있다.android:hint="숫자1 (실수 가능)"
텍스트에서 android:text=""처럼 아무것도 설정하지 않았을 때 희끄무리하게 보여지는 글자이다.
물론 저런 코드도 없이 아무것도 작성하지 않아도 이 hint에 적은 문구가 보인다.
아래의 5개가 문제에 대한 조건이다. 이것들을 감안하고 코드를 작성해야 한다.
if (num1.length()==0)
if (TextUtils.isEmpty(num1)
두 개 다 같은 의미이다. 둘 중에 어떤 코드를 사용해도 상관이 없다.
num1(주어진 숫자)의 길이가 0이거나, num1(주어진 숫자)이 비어있거나 둘 다 같은 말이니까.
대신 TextUtils를 사용하려면 import 시켜줘야 하는데 Alt + Enter로 자동 import 시켜주자.
나는 내가 고려할 수 있는 경우의 수를 전부 고려하는 것을 좋아한다. 그래서 코드에도 적용시켜줬다.
첫 번째 숫자만 비어있을 때, 두 번째 숫자만 비어있을 때, 숫자가 전부 비어있을 때를 나눠서 작성했다.
굳이 저렇게 하지 않고 전부 비어있을 때만 해도 상관은 없다.
Toast.makeText(getApplicationContext(),"입력이 하나도 없습니다.", Toast.LENGTH_SHORT).show();
토스트 메시지(Toast)는 경고 문구다. 화면 하단에 작게 팝업창으로 뜨는 문구이다.
조금 더 길게 띄워주고 싶다면 LENGTH_SHORT를 LENGTH_LONG으로 바꿔주면 더 오래 남아있는다.if (num2.equals("0"))
'만약에 num2(나누려는 숫자)이 0이라면'을 의미하는 코드다. 나머지를 구하는 것도 결국 나눠야 하니까
나눗셈말고 나머지 버튼과 연산에도 이 코드를 작성해야 하는 것을 잊지 말자. 여기서 주의할 점 하나.
자바 문법에서는 문자열 비교를 할 때 'if (num2 == "0")'이 코드는 인식이 안 된다. 문자열은 무조건 equals를 사용하자.
result = Float.parseFloat(num1) / Float.parseFloat(num2);
별 건 아니다. 앞의 예제와는 달리 실수라서 여기 코드도 바꿔줘야 한다는 것을 잊지말자.
참고로 Integer.parseInt, Double.parseDouble, Float.parseFloat 같은 형태의 문법을 따르니 알아두자.
직접 풀어보기 4-3 실행 결과열흘이다.
더도 말고 덜도 말고 딱 열흘.
이 문제를 풀기 위해, 아무것도 모르는 상태에서 온갖 영상과 자료를 뒤져가면서 하루종일 몰두한 시간이다.
진짜 대학을 다니면서 4.5로 과탑을 했을 때보다 훨씬 행복하다.
기쁨에 사무쳐 여운이 가시지 않는다.
입에서 '와'라는 탄성만이 연이어 나를 사로잡는다.
내가 해냈다.
위 그림은인랩의 매크로 탐지그래프 과정 중 일부분이다.
유저의 키보드 신호와 행동 패턴을 하나의 시간 요소로 보고, 주파수 측면으로 변형하는 것이다.
그럼 위처럼 일반 유저와 어뷰저의 행동 패턴이 두드러지게 바뀌는 것을 볼 수 있다.
이 변환에 사용하는 것이 바로 '푸리에 변환'이다.
이것은 내가 정말 좋아하는 영상 중 하나이다.
Veritasium이라는 유튜브의 영상으로, 아날로그 적분에 대한 영상이 담겨있다.
더욱이 아날로그 컴퓨터란 무엇인지, 이것이 어떤 변천을 거쳤는지도 가볍게 알 수 있다.
아날로그 컴퓨터의 기원이 되는 이 파동분석기는 William Thomson이라는 사람이 고안했다.
현재는 Kelvin이라는 이름으로 잘 알려져 있으며,절대온도의 그 '캘빈'이 맞다.
내용 중에서 여운이 남았던 것은, 수학과 파동분석기를 이용한다면 조수(파도)를 예측할 수 있다는 것이다.
바로 이 과정에 사용하는 것이 바로 '푸리에 변환'이다.
조수 예측을 아주 제대로 사용한 것이 '제 2차 세계대전'이다.
연합군이 재빠른 침공을 위해 조수를 예측하여, 언제가 가장 유리한지 파악하게 해주었다.
제 2차 세계 대전을 하니 생각나는 이야기가 하나 더 있다.
제 2차 세계대전에서 미국은 나가사키와 히로시마에 원자폭탄을 투하했다.
이로 인해 전세계 사람들은 에너지의 위험성을 알게 되었다.
물론 그것은 방대한 에너지 때문만은 아닐 것이다. 강력한 방사능을 포함하고 있으니 문제가 되는 것이다.
그래서 각국에서 핵 연료에 대한 모든 활동을 금지하는 조항을 체결하기로 했다.
하지만 당시 소련은, 미국의 핵 군사력 강화를 위한 책략이라 여겼고, 곧 의미가 퇴색했다.
타국에서 핵을 연구하는지 아닌지 감시해야만 하는 상황에 닥쳤다.
방사성 동위원소가 대기 중에서는 수 천km를 날아가기 때문에 감지가 쉽다.
해저에서도 특수한 소리를 잡는 청음기로 포착이 쉽다.
하지만 지하라면 이야기가 달라진다. 방사성 동위원소도 소리도 널리 퍼지지 않는다.
오직 진동만이 전달되는데, 이를 잡기 위해 사용한 것이 '푸리에 변환'이다.
그리고 이 계산을 빠르게 하기 위해서 '고속 푸리에 변환'이 나온 것이다.
빠르게 적국의 핵 실험을 포착해야 하기에 당연한 이유이다.
(참고로 위 영상도Veritasium의 유튜브이다.)
필요가 있어야 배움이 잘 된다.
FFT를 알기 위해서는 DFT를 알아야 한다.
DFT를 알기 위해서는 FT를 알아야 하고, Convolution을 알아야 한다.
하나하나 근원을 따라가며 차근차근 이해를 하면서 거슬러 올라왔다.
위 내용을 전부 이해했더라도, 코드로 옮기는 과정은 또 다른 일이었다.
그래도 많은 참고 자료를 확인하면서 AC를 뚫는 쾌거를 이뤘다.
위에서 설명한 수학 개념들과 유도 과정들은, 참고 자료와 함께 글로 작성할 예정이다.
여기서는 간단(?)하게 어떤 식으로 접근했는지 설명을 한다.
최대한 일관성있게, 일반적이게, 직관적으로 보이도록 노력했다.
1067번: 이동
N개의 수가 있는 X와 Y가 있다. 이때 X나 Y를 순환 이동시킬 수 있다. 순환 이동이란 마지막 원소를 제거하고 그 수를 맨 앞으로 다시 삽입하는 것을 말한다. 예를 들어, {1, 2, 3}을 순환 이동시키면
www.acmicpc.net
티어가 높을수록 문제 자체는 쉬워지는 느낌이다.
하지만 그 안에 숨어있는 묘리를 파헤쳐야 한달까...
X와 Y가 있을 때, 둘 다 순환 이동(queue의 rotate 연산)이 가능하다.
X와 Y의 요소를 각각 곱하고 더하는 연산을 한다고 했을 때, 가능한 최댓값을 묻는 문제이다.
정말 간단하게 생각한다면, O(N^2)으로 풀 수 있다.
문제에서 요구하는 연산을 수행하고, 최댓값과 비교하고, 순환 이동을 한다. 이걸 반복한다.
이 순환 이동에 유의해야 한다. 푸리에 변환의 연산곱에 대한 힌트다.
우선 호출 부분이다.
기본적으로 빠른 입력을 받는 sys, stdin.readlin을 사용했다.
cmath의 exp(자연 상수 e)와 pi(원주율 𝝿)를 호출한다.
이때 math와 cmath의 차이점은 실수와 복소수의 차이다.
math, cmath 모두 exp, pi를 지원하지만, 푸리에 변환은 복소수 개념에서 동작한다.
따라서 from math import exp, pi가 아닌, from cmath import exp, pi를 해야 한다.
전체적인 Main 코드의 흐름을 짚어보자.
리스트의 길이를 입력받고, 아무튼 무슨 연산을 해서 N을 설정한다.
설정한 N을 이용해서 X와 Y 리스트를 입력받아서 아무튼 무슨 연산을 수행한다.
그리고 각각 FFT(고속 푸리에 변환)을 한다.
X_FFT와 Y_FFT를 각각 곱한 뒤, IFFT(역 고속 푸리에 변환)을 한다.
이 값들 중 가장 큰 값을 찾아내면 정답이다.
bit_length() 내장 함수는, 숫자가 몇 자리 bit를 갖는지 반환하는 함수다.
입력받은 length의 bit를 세고, 이것보다 한 자리 더 크게 shift 연산을 하여 N에 저장한다.
그렇다면 N은 무슨 의미일까.
예를 들어 length가 3이라고 가정해보자.
그럼 3은 2진수로 11이기에, length.bit_length()를 하면 2가 나온다.
만약 1 << length.bit_length()를 하면 1을 왼쪽shift를 2칸하여 100이 된다.
즉, 1 << length.bit_length()는 현재 숫자에서 (큰 쪽으로) 가장 가까운 2의 제곱수가 된다.
그럼 length.bit_length()보다 1 크게 shift하면?
현재 숫자에서 (큰 쪽으로) 2번째로 가까운 2의 제곱수가 된다.
3이라면, 3보다 큰 2의 제곱수들이 4, 8, 16, 32, ... 있으니 2번째인 8을 나타낸다.
15라면, 15보다 큰 2의 제곱수들이 16, 32, 64, 128, ... 있으니 2번째인 32를 나타낸다.
이렇게 구하는 이유는 바로 밑에서 알 수 있다.
기본적으로 이 문제를 해결하는 아이디어는 이렇다.
X와 Y 중 하나를 뒤집고, 나머지 하나는 2배만큼 만들어준다.
(푸리에 변환(fourier transform)의 기본인합성곱(convolution) 연산을 안다는 전제 하에 설명한다.)
예를 들어서 X가 [1, 2, 3, 4]이고 Y가 [5, 6, 7, 8]이라고 가정해보자.
그럼 X는 [1, 2, 3, 4, 1, 2, 3, 4]로 두고, Y는 [8, 7, 6, 5, 0, 0, 0, 0]으로 둔다.
이 상태로 convolution하는 것이다!
그렇게 나온 값들 중 최댓값이 그럼 정답이 된다.
FFT의 기본 동작은 divide and conquer(분할 정복)이다.
그 중에서도 리스트의 길이가 2의 제곱일 때만 분할 정복이 가능하다.
(정확하게는 2의 제곱이 아니어도 불가능한 건 아니지만, 과정이 복잡해진다.)
그래서 처음에 0을 패딩해주기 위해서, N을 2의 제곱수로 구한 것이다.
예를 들어서 length가 3이었다면, 3 * 2 = 6으로, 가장 첫 2의 제곱수는 4로 자리가 부족하다.
그래서 2번째로 가까운 2의 제곱수를 구해준 것이다.
X 리스트를 입력받고, 2배로 만든다. 그리고 남은 자리를 0으로 패딩한다.
Y 리스트를 입력받고, 뒤집는다. 그리고 남은 자리를 0으로 패딩한다.
예를 들어서 X가 [1, 2, 3]이고, Y가 [5, 6, 7]이라고 가정해보자.
그럼 X는 [1, 2, 3, 1, 2, 3, 0, 0]이고, Y는 [7, 6, 5, 0, 0, 0, 0, 0]가 된다.
물론 length가 2의 제곱수라면 의미없는 0이 뒤에 붙을 수 있다.
하지만 0이기 때문에 convolution 연산의 결과는 0으로 무시가 가능하다.
X와 Y를 각각 FFT 연산을 하여 저장한다.
그리고 두 요소를 각각 곱해서 mul이라는 리스트에 따로 저장해준다.
mul 리스트를 IFFT(역 연산)를 수행하면, 원하는 결괏값들이 나온다!
역 연산을 수행해서 나온 inverse 리스트는 현재 복소수가 들어가 있다.
이렇게 정규화하는 이유는 FFT 과정 중에 각 요소가 N만큼 곱해졌기 때문이다.
이를 전체 길이N으로 나누어 정규화해야 한다.
또한, 여기서 원하는 값은 정수다. 즉 변환을 해줘야 한다.
real 메소드를 사용하면, a + bi의 복소수 형태에서 실수만을 취해준다.
복소수만큼 손실이 발생했기 때문에, round() 함수로 반올림 해준다.
그리고? 이들 중 최댓값(max)를 구하면 된다.
대망의 FFT 알고리즘이다.
수학자 두 명이 고안해낸 '쿨리-튜키 알고리즘(Cooley-Tukey algorithm)'을 따라간다.
더 넓은 범위, 더 빠른 속도를 원한다면 'NTT(Number Theoretic Transform)'라는 알고리즘을 사용하기도 한다.
정수론의 소수(MOD)와 원시근을 이용한 방법이다. 하지만 여기서는 사용하지 않는다.
쉽게 말하면 DFT(이산 푸리에 변환)에서 중복으로 발생하는 연산이 있다.
중복은 주어진 전체 길이를 반으로 쪼갰을 때를 기준으로 존재한다.
따라서 반으로 나눠서 다시 푸리에 변환을 진행하는 방식으로 수행한다.
리스트 a와 정수 inverse를 입력받는다.
a는 FFT할 리스트이고, 정변환인지 역변환인지 나타내는 inverse 변수다.
놀랍게도 FFT와 IFFT는 단 하나의 값만 다르다!
따라서 코드를 아주 손쉽게 재사용할 수 있다.
리스트 a의 길이는 추후에도 사용하기에 N에 저장해준다.
N이 1이라면 더 이상 쪼갤 수 없다. 이때는 a를 그대로 반환하면 된다.
위에서 푸리에 변환을 나눈다고 언급했다.
기함수와 우함수의 특징을 이용하여, 홀수 번째와 짝수 번째 index를 기준으로 나눈다.
(기함수는, 다른 말로 홀함수이다. y(-x) = -y(x)가 성립하는 특징을 갖는다.)
(우함수는, 다른 말로 짝함수이다. y(x) = y(-x)가 성립하는 특징을 갖는다.)
나눈 리스트는 FFT로 재귀를 돌려준다.
나중에 곱해주기 위해서 가중치를 미리 리스트로 만들어둔다.
푸리에 변환에 의해 가중치 e^2𝝿jn을 곱해주어야 한다.
(이 가중치는 복소평면상에서 단위원 위의 점과 같다. 오일러 공식eiθ =cosθ+isinθ을 응용한다.)
(파이썬에서는 복소수를 j로 사용한다.)
중복 값을 나눠서 계산하기에,범위는 N // 2까지만 계산하면 된다.
위에서 언급한 FFT와 IFFT가 다른 단 하나의 부분이 이 코드다.
실제로 FFT는 2𝝿jn을 가중치로 사용하지만, IFFT는 -2𝝿jn을 가중치로 사용한다.
(역연산을 취하려면 fourier matrix를 뒤집어야 한다. 이때 -1이라는 값이 등장한다.)
따라서 처음 FFT 함수를 호출할 때, inverse에 1 혹은 -1을 입력받아서 맨 앞에 부호로써 곱해준다.
두 가지 리스트를 합쳐서 반환하면 끝난다.
본래는 전체 길이(N)만큼 0으로 초기화 한 다음에, index에 맞게 값을 넣어주어야 한다.
하지만 파이썬의 리스트는 + 연산자를 지원해서, 앞뒤의 리스트를 구한 뒤 더해주면 된다.
FFT의 연산 결과(원리)에 의해서 위와 같은 과정을 따라간다.
결과적으로 FFT와 IFFT를 구분하지 않고 하나의 함수로 묶을 수 있었다.
또한, 처음에 받는 리스트의 길이가 2의 제곱수이든 아니든 상관하지 않고 동작할 수 있다.
최대한 간결하고, 정수만 담아서 깔끔하게 작성했다.
무엇보다 열흘의 시간이 한 번에 터지는 그 희열이 엄청났다.
조만간 NTT도 도전할 듯하다.데이터 추가를 위해 무엇을 기준으로 삼을지 고민해보았다.
옥냥이가 포인트 예측(이하 불안전한 놀이터)을 연다는 건, 지금의 실력을 고려해야 한다는 말과 같다.
그래서 마리오카트 점수 변화를 그래프로 그려보았다.
└ score 점수는 옥냥이와 올냥이 유튜브 기준, 게임 입장 시 처음 뜨는 점수를 기반으로 시각화했다.
붉은 색으로 보이는 점 부분은 '사관 데이터'의 첫 기록 날짜다.
가장 첫 날인 2021년 6월 9일의 데이터를 지금 넣는 게 과연 의미가 있을까?
저때는 정말 뉴비였고, 지금 존재하는 DLC 맵이 없는 경우도 있었다.
그렇게 죽죽 가파른 기울기로 점수가 올라갔고, 저 빨간 포인트.
저 빨간 점이 7000을 가기 직전의 점수로, 딱 기준으로 삼기 적절해보인다.
2022년 2월 4일을 기준으로, 점수 기울기가 완만해지기 시작한다.
그리고 점수도 7000대 ~ 8000대로 어느정도 안착한 모습을 보여준다.
(마치 주식 시장의 횡보 구간처럼 보인다.)
심지어 7000대까지는 계속 상승만 하다가 8000대 도달하니 하락하는 모습을 처음 보인다.
즉 옥냥이는 8000대의 실력이 딱이라는 이야기다.
현재로써 2021년의 데이터는 무의미하다.
따라서 아래의 7달치 데이터를 최종적으로 추가하고 마무리하기로 결정했다.
ㆍ 2022년 4월 12일
ㆍ 2023년 8월 21일, 9월 21일, 10월 23일, 12월 5일, 12월 22일
ㆍ 2024년 2월 27일
이제 해야 할 건... 저 1시간 반가량 있는 영상을 보며 직접 데이터를 다시 노가다하자.
물론 7달치를 말이다.
결국 학습하고자 하는 모든 데이터를 확인했다.
놓치고 있던 점이 하나 있었는데,2024년 2월 27일부로 트위치가 한국 사업에서 빠졌던 점이다.
즉,2024년 2월 27일 마리오 카트 방송은 놀이터가 열리지 않았다...!
따라서 2023년 데이터까지만 추가해줬다. 총 632 * 17의 데이터프레임을 완성했다.
혹시라도 course(경기장)이나 위의 csv 데이터가 필요하다면 아래를 참고하자.
https://github.com/miny-genie/RTC-mariokart-8-AI